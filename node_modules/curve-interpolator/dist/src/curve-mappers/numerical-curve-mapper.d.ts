import { AbstractCurveMapper } from "./abstract-curve-mapper";
import { SplineSegmentOptions } from "../core/interfaces";
export interface CurveLengthCalculationOptions extends SplineSegmentOptions {
    gauss?: [number[], number[]];
    t0?: number;
    t1?: number;
}
/**
 * This curve mapper implementation uses a numerical integration method (Gauss Legendre)
 * in order to approximate curve segment lengths. For re-parameterization of the curve
 * function in terms of arc length, a number of precalculated lengths (samples) is used
 * to fit a monotone piecewise cubic function using the approach suggested here:
 * https://stackoverflow.com/questions/35275073/uniform-discretization-of-bezier-curve
 */
export declare class NumericalCurveMapper extends AbstractCurveMapper {
    _nSamples: number;
    _gauss: number[][];
    /**
     *
     * @param onInvalidateCache callback function to be invoked when cache is invalidated
     * @param nQuadraturePoints the number of Gauss-Legendre Quadrature points to use for arc length approximation
     * @param nInverseSamples the number of arc length samples to use to fit an inverse function for calculating t from arc length
     */
    constructor(nQuadraturePoints?: number, nInverseSamples?: number, onInvalidateCache?: () => void);
    /**
     * Clear cache
     */
    _invalidateCache(): void;
    get arcLengths(): any;
    /**
     * Get samples for inverse function from cache if present, otherwise calculate and put
     * in cache for re-use.
     * @param idx curve segment index
     * @returns Lengths, slopes and coefficients for inverse function
     */
    getSamples(idx: number): [number[], number[], number[], number[]];
    /**
     * Computes the arc length of a curve segment
     * @param index index of curve segment
     * @param t0 calculate length from t
     * @param t1 calculate length to t
     * @returns arc length between t0 and t1
     */
    computeArcLength(index: number, t0?: number, t1?: number): number;
    /**
     * Calculate a running sum of arc length for mapping a position on the curve (u)
     * to the position at the corresponding curve segment (t).
     * @returns array with accumulated curve segment arc lengths
     */
    computeArcLengths(): number[];
    /**
     * Calculate t from arc length for a curve segment
     * @param idx segment index
     * @param len length
     * @returns time (t) along curve segment matching the input length
     */
    inverse(idx: number, len: number): number;
    /**
     * Get curve length at u
     * @param u normalized uniform position along the spline curve
     * @returns length in point coordinates
     */
    lengthAt(u: number): number;
    /**
     * Maps a uniform time along the curve to non-uniform time (t)
     * @param u normalized uniform position along the spline curve
     * @returns t encoding segment index and local time along curve
     */
    getT(u: number): number;
    /**
     * Maps a non-uniform time along the curve to uniform time (u)
     * @param t non-uniform time along curve
     * @returns uniform time along curve
     */
    getU(t: number): number;
}
