// node_modules/curve-interpolator/dist/index.esm.js
var extendStatics = function(d, b) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      b2.hasOwnProperty(p) && (d2[p] = b2[p]);
  }, extendStatics(d, b);
};
function __extends(d, b) {
  function __() {
    this.constructor = d;
  }
  extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++)
      for (var p in s = arguments[i])
        Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    return t;
  }, __assign.apply(this, arguments);
};
function extrapolateControlPoint(u, v) {
  for (var e = new Array(u.length), i = 0; i < u.length; i++)
    e[i] = 2 * u[i] - v[i];
  return e;
}
function getControlPoints(idx, points, closed) {
  var p0, p1, p2, p3, maxIndex = points.length - 1;
  if (closed)
    p0 = points[idx - 1 < 0 ? maxIndex : idx - 1], p1 = points[idx % points.length], p2 = points[(idx + 1) % points.length], p3 = points[(idx + 2) % points.length];
  else {
    if (idx === maxIndex)
      throw Error("There is no spline segment at this index for a closed curve!");
    p1 = points[idx], p2 = points[idx + 1], p0 = idx > 0 ? points[idx - 1] : extrapolateControlPoint(p1, p2), p3 = idx < maxIndex - 1 ? points[idx + 2] : extrapolateControlPoint(p2, p1);
  }
  return [p0, p1, p2, p3];
}
function getSegmentIndexAndT(ct, points, closed) {
  void 0 === closed && (closed = false);
  var nPoints = closed ? points.length : points.length - 1;
  if (1 === ct)
    return { index: nPoints - 1, weight: 1 };
  var p = nPoints * ct, index = Math.floor(p);
  return { index, weight: p - index };
}
function fill(v, val) {
  for (var i = 0; i < v.length; i++)
    v[i] = val;
  return v;
}
function map(v, func) {
  for (var i = 0; i < v.length; i++)
    v[i] = func(v[i], i);
  return v;
}
function reduce(v, func, r) {
  void 0 === r && (r = 0);
  for (var i = 0; i < v.length; i++)
    r = func(r, v[i], i);
  return r;
}
function copyValues(source, target) {
  target = target || new Array(source.length);
  for (var i = 0; i < source.length; i++)
    target[i] = source[i];
  return target;
}
function simplify2d(inputArr, maxOffset, maxDistance) {
  var _a;
  if (void 0 === maxOffset && (maxOffset = 1e-3), void 0 === maxDistance && (maxDistance = 10), inputArr.length <= 4)
    return inputArr;
  for (var _b = inputArr[0], o0 = _b[0], o1 = _b[1], arr = inputArr.map(function(d) {
    return [d[0] - o0, d[1] - o1];
  }), _c = arr[0], a0 = _c[0], a1 = _c[1], sim = [inputArr[0]], i = 1; i + 1 < arr.length; i++) {
    var _d = arr[i], t0 = _d[0], t1 = _d[1], _e = arr[i + 1], b0 = _e[0], b1 = _e[1];
    if (b0 - t0 != 0 || b1 - t1 != 0) {
      var proximity = Math.abs(a0 * b1 - a1 * b0 + b0 * t1 - b1 * t0 + a1 * t0 - a0 * t1) / Math.sqrt(Math.pow(b0 - a0, 2) + Math.pow(b1 - a1, 2)), dir = [a0 - t0, a1 - t1], len = Math.sqrt(Math.pow(dir[0], 2) + Math.pow(dir[1], 2));
      (proximity > maxOffset || len >= maxDistance) && (sim.push([t0 + o0, t1 + o1]), a0 = (_a = [t0, t1])[0], a1 = _a[1]);
    }
  }
  var last = arr[arr.length - 1];
  return sim.push([last[0] + o0, last[1] + o1]), sim;
}
function clamp(value, min, max) {
  return void 0 === min && (min = 0), void 0 === max && (max = 1), value < min ? min : value > max ? max : value;
}
function binarySearch(targetValue, accumulatedValues) {
  var min = accumulatedValues[0];
  if (targetValue >= accumulatedValues[accumulatedValues.length - 1])
    return accumulatedValues.length - 1;
  if (targetValue <= min)
    return 0;
  for (var left = 0, right = accumulatedValues.length - 1; left <= right; ) {
    var mid = Math.floor((left + right) / 2), lMid = accumulatedValues[mid];
    if (lMid < targetValue)
      left = mid + 1;
    else {
      if (!(lMid > targetValue))
        return mid;
      right = mid - 1;
    }
  }
  return Math.max(0, right);
}
var EPS = Math.pow(2, -42);
function cuberoot(x) {
  var y = Math.pow(Math.abs(x), 1 / 3);
  return x < 0 ? -y : y;
}
function getQuadRoots(a, b, c) {
  if (Math.abs(a) < EPS)
    return Math.abs(b) < EPS ? [] : [-c / b];
  var D = b * b - 4 * a * c;
  return Math.abs(D) < EPS ? [-b / (2 * a)] : D > 0 ? [(-b + Math.sqrt(D)) / (2 * a), (-b - Math.sqrt(D)) / (2 * a)] : [];
}
function getCubicRoots(a, b, c, d) {
  if (Math.abs(a) < EPS)
    return getQuadRoots(b, c, d);
  var roots, p = (3 * a * c - b * b) / (3 * a * a), q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);
  if (Math.abs(p) < EPS)
    roots = [cuberoot(-q)];
  else if (Math.abs(q) < EPS)
    roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
  else {
    var D = q * q / 4 + p * p * p / 27;
    if (Math.abs(D) < EPS)
      roots = [-1.5 * q / p, 3 * q / p];
    else if (D > 0) {
      roots = [(u = cuberoot(-q / 2 - Math.sqrt(D))) - p / (3 * u)];
    } else {
      var u = 2 * Math.sqrt(-p / 3), t = Math.acos(3 * q / p / u) / 3, k = 2 * Math.PI / 3;
      roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)];
    }
  }
  for (var i = 0; i < roots.length; i++)
    roots[i] -= b / (3 * a);
  return roots;
}
function dot(v1, v2) {
  if (v1.length !== v2.length)
    throw Error("Vectors must be of equal length!");
  for (var p = 0, k = 0; k < v1.length; k++)
    p += v1[k] * v2[k];
  return p;
}
function cross(v1, v2, target) {
  if (!(v1.length > 3)) {
    target = target || new Array(3);
    var ax = v1[0], ay = v1[1], az = v1[2] || 0, bx = v2[0], by = v2[1], bz = v2[2] || 0;
    return target[0] = ay * bz - az * by, target[1] = az * bx - ax * bz, target[2] = ax * by - ay * bx, target;
  }
}
function add(v1, v2, target) {
  target = target || new Array(v1.length);
  for (var k = 0; k < v1.length; k++)
    target[k] = v1[k] + v2[k];
  return target;
}
function sub(v1, v2, target) {
  target = target || new Array(v1.length);
  for (var k = 0; k < v1.length; k++)
    target[k] = v1[k] - v2[k];
  return target;
}
function sumOfSquares(v1, v2) {
  for (var sumOfSquares2 = 0, i = 0; i < v1.length; i++)
    sumOfSquares2 += (v1[i] - v2[i]) * (v1[i] - v2[i]);
  return sumOfSquares2;
}
function magnitude(v) {
  for (var sumOfSquares2 = 0, i = 0; i < v.length; i++)
    sumOfSquares2 += v[i] * v[i];
  return Math.sqrt(sumOfSquares2);
}
function distance(p1, p2) {
  var sqrs = sumOfSquares(p1, p2);
  return 0 === sqrs ? 0 : Math.sqrt(sqrs);
}
function normalize(v, target) {
  var u = target ? copyValues(v, target) : v, squared = reduce(u, function(s, c) {
    return s + Math.pow(c, 2);
  }), l = Math.sqrt(squared);
  return 0 === l ? fill(u, 0) : map(u, function(c) {
    return c / l;
  });
}
function orthogonal(v, target) {
  if (v.length > 2)
    throw Error("Only supported for 2d vectors");
  var u = target ? copyValues(v, target) : v, x = -u[1];
  return u[1] = u[0], u[0] = x, u;
}
function rotate2d(vector, angle, anchor, target) {
  void 0 === angle && (angle = 0), void 0 === anchor && (anchor = [0, 0]);
  var c = Math.cos(angle), s = Math.sin(angle), vx = vector[0] - anchor[0], vy = vector[1] - anchor[1];
  return (target = target || vector)[0] = vx * c - vy * s + anchor[0], target[1] = vx * s + vy * c + anchor[1], target;
}
function rotate3d(vector, axis, angle, target) {
  void 0 === axis && (axis = [0, 1, 0]), void 0 === angle && (angle = 0);
  var c = Math.cos(angle), s = Math.sin(angle), t = 1 - c, vx = vector[0], vy = vector[1], vz = vector[2], ax = axis[0], ay = axis[1], az = axis[2], tx = t * ax, ty = t * ay;
  return (target = target || vector)[0] = (tx * ax + c) * vx + (tx * ay - s * az) * vy + (tx * az + s * ay) * vz, target[1] = (tx * ay + s * az) * vx + (ty * ay + c) * vy + (ty * az - s * ax) * vz, target[2] = (tx * az - s * ay) * vx + (ty * az + s * ax) * vy + (t * az * az + c) * vz, target;
}
function calcKnotSequence(p0, p1, p2, p3, alpha) {
  if (void 0 === alpha && (alpha = 0), 0 === alpha)
    return [0, 1, 2, 3];
  var deltaT = function(u, v) {
    return Math.pow(sumOfSquares(u, v), 0.5 * alpha);
  }, t1 = deltaT(p1, p0), t2 = deltaT(p2, p1) + t1;
  return [0, t1, t2, deltaT(p3, p2) + t2];
}
function calculateCoefficients(p0, p1, p2, p3, options) {
  for (var tension = Number.isFinite(options.tension) ? options.tension : 0.5, alpha = Number.isFinite(options.alpha) ? options.alpha : null, knotSequence = alpha > 0 ? calcKnotSequence(p0, p1, p2, p3, alpha) : null, coefficientsList = new Array(p0.length), k = 0; k < p0.length; k++) {
    var u = 0, v = 0, v0 = p0[k], v1 = p1[k], v2 = p2[k], v3 = p3[k];
    if (knotSequence) {
      var t0 = knotSequence[0], t1 = knotSequence[1], t2 = knotSequence[2], t3 = knotSequence[3];
      t1 - t2 != 0 && (t0 - t1 != 0 && t0 - t2 != 0 && (u = (1 - tension) * (t2 - t1) * ((v0 - v1) / (t0 - t1) - (v0 - v2) / (t0 - t2) + (v1 - v2) / (t1 - t2))), t1 - t3 != 0 && t2 - t3 != 0 && (v = (1 - tension) * (t2 - t1) * ((v1 - v2) / (t1 - t2) - (v1 - v3) / (t1 - t3) + (v2 - v3) / (t2 - t3))));
    } else
      u = (1 - tension) * (v2 - v0) * 0.5, v = (1 - tension) * (v3 - v1) * 0.5;
    var a = 2 * v1 - 2 * v2 + u + v, b = -3 * v1 + 3 * v2 - 2 * u - v, c = u, d = v1;
    coefficientsList[k] = [a, b, c, d];
  }
  return coefficientsList;
}
function valueAtT(t, coefficients) {
  var t2 = t * t, t3 = t * t2;
  return coefficients[0] * t3 + coefficients[1] * t2 + coefficients[2] * t + coefficients[3];
}
function derivativeAtT(t, coefficients) {
  var t2 = t * t;
  return 3 * coefficients[0] * t2 + 2 * coefficients[1] * t + coefficients[2];
}
function secondDerivativeAtT(t, coefficients) {
  return 6 * coefficients[0] * t + 2 * coefficients[1];
}
function findRootsOfT(lookup, coefficients) {
  var a = coefficients[0], b = coefficients[1], c = coefficients[2], x = coefficients[3] - lookup;
  return 0 === a && 0 === b && 0 === c && 0 === x ? [0] : getCubicRoots(a, b, c, x).filter(function(t) {
    return t > -EPS && t <= 1 + EPS;
  }).map(function(t) {
    return clamp(t, 0, 1);
  });
}
function evaluateForT(func, t, coefficients, target) {
  void 0 === target && (target = null), target = target || new Array(coefficients.length);
  for (var k = 0; k < coefficients.length; k++)
    target[k] = func(t, coefficients[k]);
  return target;
}
var AbstractCurveMapper = function() {
  function AbstractCurveMapper2(onInvalidateCache) {
    void 0 === onInvalidateCache && (onInvalidateCache = null), this._alpha = 0, this._tension = 0.5, this._closed = false, this._onInvalidateCache = null, this._onInvalidateCache = onInvalidateCache, this._cache = { arcLengths: null, coefficients: null };
  }
  return AbstractCurveMapper2.prototype._invalidateCache = function() {
    this.points && (this._cache = { arcLengths: null, coefficients: null }, this._onInvalidateCache && this._onInvalidateCache());
  }, Object.defineProperty(AbstractCurveMapper2.prototype, "alpha", { get: function() {
    return this._alpha;
  }, set: function(alpha) {
    Number.isFinite(alpha) && alpha !== this._alpha && (this._invalidateCache(), this._alpha = alpha);
  }, enumerable: false, configurable: true }), Object.defineProperty(AbstractCurveMapper2.prototype, "tension", { get: function() {
    return this._tension;
  }, set: function(tension) {
    Number.isFinite(tension) && tension !== this._tension && (this._invalidateCache(), this._tension = tension);
  }, enumerable: false, configurable: true }), Object.defineProperty(AbstractCurveMapper2.prototype, "points", { get: function() {
    return this._points;
  }, set: function(points) {
    if (!points || points.length < 2)
      throw Error("At least 2 control points are required!");
    this._points = points, this._invalidateCache();
  }, enumerable: false, configurable: true }), Object.defineProperty(AbstractCurveMapper2.prototype, "closed", { get: function() {
    return this._closed;
  }, set: function(closed) {
    closed = !!closed, this._closed !== closed && (this._invalidateCache(), this._closed = closed);
  }, enumerable: false, configurable: true }), AbstractCurveMapper2.prototype.reset = function() {
    this._invalidateCache();
  }, AbstractCurveMapper2.prototype.evaluateForT = function(func, t, target) {
    var _a = getSegmentIndexAndT(t, this.points, this.closed), index = _a.index;
    return evaluateForT(func, _a.weight, this.getCoefficients(index), target);
  }, AbstractCurveMapper2.prototype.getCoefficients = function(idx) {
    if (this.points) {
      if (this._cache.coefficients || (this._cache.coefficients = /* @__PURE__ */ new Map()), !this._cache.coefficients.has(idx)) {
        var _a = getControlPoints(idx, this.points, this.closed), coefficients = calculateCoefficients(_a[0], _a[1], _a[2], _a[3], { tension: this.tension, alpha: this.alpha });
        this._cache.coefficients.set(idx, coefficients);
      }
      return this._cache.coefficients.get(idx);
    }
  }, AbstractCurveMapper2;
}();
var SegmentedCurveMapper = function(_super) {
  function SegmentedCurveMapper2(subDivisions, onInvalidateCache) {
    void 0 === subDivisions && (subDivisions = 300), void 0 === onInvalidateCache && (onInvalidateCache = null);
    var _this = _super.call(this, onInvalidateCache) || this;
    return _this._subDivisions = subDivisions, _this;
  }
  return __extends(SegmentedCurveMapper2, _super), Object.defineProperty(SegmentedCurveMapper2.prototype, "arcLengths", { get: function() {
    return this._cache.arcLengths || (this._cache.arcLengths = this.computeArcLengths()), this._cache.arcLengths;
  }, enumerable: false, configurable: true }), SegmentedCurveMapper2.prototype._invalidateCache = function() {
    _super.prototype._invalidateCache.call(this), this._cache.arcLengths = null;
  }, SegmentedCurveMapper2.prototype.computeArcLengths = function() {
    var current, lengths = [], last = this.evaluateForT(valueAtT, 0), sum = 0;
    lengths.push(0);
    for (var p = 1; p <= this._subDivisions; p++)
      sum += distance(current = this.evaluateForT(valueAtT, p / this._subDivisions), last), lengths.push(sum), last = current;
    return lengths;
  }, SegmentedCurveMapper2.prototype.lengthAt = function(u) {
    var arcLengths = this.arcLengths;
    return u * arcLengths[arcLengths.length - 1];
  }, SegmentedCurveMapper2.prototype.getT = function(u) {
    var arcLengths = this.arcLengths, il = arcLengths.length, targetArcLength = u * arcLengths[il - 1], i = binarySearch(targetArcLength, arcLengths);
    if (arcLengths[i] === targetArcLength)
      return i / (il - 1);
    var lengthBefore = arcLengths[i];
    return (i + (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) / (il - 1);
  }, SegmentedCurveMapper2.prototype.getU = function(t) {
    if (0 === t)
      return 0;
    if (1 === t)
      return 1;
    var arcLengths = this.arcLengths, al = arcLengths.length - 1, totalLength = arcLengths[al], tIdx = t * al, subIdx = Math.floor(tIdx), l1 = arcLengths[subIdx];
    if (tIdx === subIdx)
      return l1 / totalLength;
    var t0 = subIdx / al;
    return (l1 + distance(this.evaluateForT(valueAtT, t0), this.evaluateForT(valueAtT, t))) / totalLength;
  }, SegmentedCurveMapper2;
}(AbstractCurveMapper);
var lut = [[[-0.906179845938664, 0.23692688505618908], [-0.5384693101056831, 0.47862867049936647], [0, 0.5688888888888889], [0.5384693101056831, 0.47862867049936647], [0.906179845938664, 0.23692688505618908]], [[-0.932469514203152, 0.17132449237917036], [-0.6612093864662645, 0.3607615730481386], [-0.2386191860831969, 0.46791393457269104], [0.2386191860831969, 0.46791393457269104], [0.6612093864662645, 0.3607615730481386], [0.932469514203152, 0.17132449237917036]], [[-0.9491079123427585, 0.1294849661688697], [-0.7415311855993945, 0.27970539148927664], [-0.4058451513773972, 0.3818300505051189], [0, 0.4179591836734694], [0.4058451513773972, 0.3818300505051189], [0.7415311855993945, 0.27970539148927664], [0.9491079123427585, 0.1294849661688697]], [[-0.9602898564975363, 0.10122853629037626], [-0.7966664774136267, 0.22238103445337448], [-0.525532409916329, 0.31370664587788727], [-0.1834346424956498, 0.362683783378362], [0.1834346424956498, 0.362683783378362], [0.525532409916329, 0.31370664587788727], [0.7966664774136267, 0.22238103445337448], [0.9602898564975363, 0.10122853629037626]], [[-0.9681602395076261, 0.08127438836157441], [-0.8360311073266358, 0.1806481606948574], [-0.6133714327005904, 0.26061069640293544], [-0.3242534234038089, 0.31234707704000286], [0, 0.3302393550012598], [0.3242534234038089, 0.31234707704000286], [0.6133714327005904, 0.26061069640293544], [0.8360311073266358, 0.1806481606948574], [0.9681602395076261, 0.08127438836157441]], [[-0.9739065285171717, 0.06667134430868814], [-0.8650633666889845, 0.1494513491505806], [-0.6794095682990244, 0.21908636251598204], [-0.4333953941292472, 0.26926671930999635], [-0.14887433898163122, 0.29552422471475287], [0.14887433898163122, 0.29552422471475287], [0.4333953941292472, 0.26926671930999635], [0.6794095682990244, 0.21908636251598204], [0.8650633666889845, 0.1494513491505806], [0.9739065285171717, 0.06667134430868814]], [[-0.978228658146056, 0.0556685671161736], [-0.887062599768095, 0.125580369464904], [-0.730152005574049, 0.186290210927734], [-0.519096129206811, 0.23319376459199], [-0.269543155952344, 0.262804544510246], [0, 0.2729250867779], [0.269543155952344, 0.262804544510246], [0.519096129206811, 0.23319376459199], [0.730152005574049, 0.186290210927734], [0.887062599768095, 0.125580369464904], [0.978228658146056, 0.0556685671161736]], [[-0.981560634246719, 0.0471753363865118], [-0.904117256370474, 0.106939325995318], [-0.769902674194304, 0.160078328543346], [-0.587317954286617, 0.203167426723065], [-0.36783149899818, 0.233492536538354], [-0.125233408511468, 0.249147045813402], [0.125233408511468, 0.249147045813402], [0.36783149899818, 0.233492536538354], [0.587317954286617, 0.203167426723065], [0.769902674194304, 0.160078328543346], [0.904117256370474, 0.106939325995318], [0.981560634246719, 0.0471753363865118]], [[-0.984183054718588, 0.0404840047653158], [-0.917598399222977, 0.0921214998377284], [-0.801578090733309, 0.138873510219787], [-0.64234933944034, 0.178145980761945], [-0.448492751036446, 0.207816047536888], [-0.230458315955134, 0.226283180262897], [0, 0.232551553230873], [0.230458315955134, 0.226283180262897], [0.448492751036446, 0.207816047536888], [0.64234933944034, 0.178145980761945], [0.801578090733309, 0.138873510219787], [0.917598399222977, 0.0921214998377284], [0.984183054718588, 0.0404840047653158]], [[-0.986283808696812, 0.0351194603317518], [-0.928434883663573, 0.0801580871597602], [-0.827201315069764, 0.121518570687903], [-0.687292904811685, 0.157203167158193], [-0.515248636358154, 0.185538397477937], [-0.319112368927889, 0.205198463721295], [-0.108054948707343, 0.215263853463157], [0.108054948707343, 0.215263853463157], [0.319112368927889, 0.205198463721295], [0.515248636358154, 0.185538397477937], [0.687292904811685, 0.157203167158193], [0.827201315069764, 0.121518570687903], [0.928434883663573, 0.0801580871597602], [0.986283808696812, 0.0351194603317518]], [[-0.987992518020485, 0.0307532419961172], [-0.937273392400705, 0.0703660474881081], [-0.848206583410427, 0.107159220467171], [-0.72441773136017, 0.139570677926154], [-0.570972172608538, 0.166269205816993], [-0.394151347077563, 0.186161000015562], [-0.201194093997434, 0.198431485327111], [0, 0.202578241925561], [0.201194093997434, 0.198431485327111], [0.394151347077563, 0.186161000015562], [0.570972172608538, 0.166269205816993], [0.72441773136017, 0.139570677926154], [0.848206583410427, 0.107159220467171], [0.937273392400705, 0.0703660474881081], [0.987992518020485, 0.0307532419961172]], [[-0.989400934991649, 0.027152459411754], [-0.944575023073232, 0.0622535239386478], [-0.865631202387831, 0.0951585116824927], [-0.755404408355003, 0.124628971255533], [-0.617876244402643, 0.149595988816576], [-0.458016777657227, 0.169156519395002], [-0.281603550779258, 0.182603415044923], [-0.0950125098376374, 0.189450610455068], [0.0950125098376374, 0.189450610455068], [0.281603550779258, 0.182603415044923], [0.458016777657227, 0.169156519395002], [0.617876244402643, 0.149595988816576], [0.755404408355003, 0.124628971255533], [0.865631202387831, 0.0951585116824927], [0.944575023073232, 0.0622535239386478], [0.989400934991649, 0.027152459411754]], [[-0.990575475314417, 0.0241483028685479], [-0.950675521768767, 0.0554595293739872], [-0.880239153726985, 0.0850361483171791], [-0.781514003896801, 0.111883847193403], [-0.65767115921669, 0.135136368468525], [-0.512690537086476, 0.15404576107681], [-0.351231763453876, 0.16800410215645], [-0.178484181495847, 0.176562705366992], [0, 0.179446470356206], [0.178484181495847, 0.176562705366992], [0.351231763453876, 0.16800410215645], [0.512690537086476, 0.15404576107681], [0.65767115921669, 0.135136368468525], [0.781514003896801, 0.111883847193403], [0.880239153726985, 0.0850361483171791], [0.950675521768767, 0.0554595293739872], [0.990575475314417, 0.0241483028685479]], [[-0.99156516842093, 0.0216160135264833], [-0.955823949571397, 0.0497145488949698], [-0.892602466497555, 0.076425730254889], [-0.803704958972523, 0.100942044106287], [-0.691687043060353, 0.122555206711478], [-0.559770831073947, 0.14064291467065], [-0.411751161462842, 0.154684675126265], [-0.251886225691505, 0.164276483745832], [-0.0847750130417353, 0.169142382963143], [0.0847750130417353, 0.169142382963143], [0.251886225691505, 0.164276483745832], [0.411751161462842, 0.154684675126265], [0.559770831073947, 0.14064291467065], [0.691687043060353, 0.122555206711478], [0.803704958972523, 0.100942044106287], [0.892602466497555, 0.076425730254889], [0.955823949571397, 0.0497145488949697], [0.99156516842093, 0.0216160135264833]], [[-0.992406843843584, 0.0194617882297264], [-0.96020815213483, 0.0448142267656996], [-0.903155903614817, 0.0690445427376412], [-0.822714656537142, 0.0914900216224499], [-0.720966177335229, 0.111566645547333], [-0.600545304661681, 0.128753962539336], [-0.46457074137596, 0.142606702173606], [-0.316564099963629, 0.152766042065859], [-0.160358645640225, 0.158968843393954], [0, 0.161054449848783], [0.160358645640225, 0.158968843393954], [0.316564099963629, 0.152766042065859], [0.46457074137596, 0.142606702173606], [0.600545304661681, 0.128753962539336], [0.720966177335229, 0.111566645547333], [0.822714656537142, 0.0914900216224499], [0.903155903614817, 0.0690445427376412], [0.96020815213483, 0.0448142267656996], [0.992406843843584, 0.0194617882297264]], [[-0.993128599185094, 0.0176140071391521], [-0.963971927277913, 0.0406014298003869], [-0.912234428251325, 0.062672048334109], [-0.839116971822218, 0.0832767415767047], [-0.74633190646015, 0.10193011981724], [-0.636053680726515, 0.118194531961518], [-0.510867001950827, 0.131688638449176], [-0.373706088715419, 0.142096109318382], [-0.227785851141645, 0.149172986472603], [-0.0765265211334973, 0.152753387130725], [0.0765265211334973, 0.152753387130725], [0.227785851141645, 0.149172986472603], [0.373706088715419, 0.142096109318382], [0.510867001950827, 0.131688638449176], [0.636053680726515, 0.118194531961518], [0.74633190646015, 0.10193011981724], [0.839116971822218, 0.0832767415767047], [0.912234428251325, 0.062672048334109], [0.963971927277913, 0.0406014298003869], [0.993128599185094, 0.0176140071391521]], [[-0.993752170620389, 0.0160172282577743], [-0.967226838566306, 0.0369537897708524], [-0.9200993341504, 0.0571344254268572], [-0.853363364583317, 0.0761001136283793], [-0.768439963475677, 0.0934444234560338], [-0.667138804197412, 0.108797299167148], [-0.551618835887219, 0.121831416053728], [-0.424342120207438, 0.132268938633337], [-0.288021316802401, 0.139887394791073], [-0.145561854160895, 0.14452440398997], [0, 0.14608113364969], [0.145561854160895, 0.14452440398997], [0.288021316802401, 0.139887394791073], [0.424342120207438, 0.132268938633337], [0.551618835887219, 0.121831416053728], [0.667138804197412, 0.108797299167148], [0.768439963475677, 0.0934444234560338], [0.853363364583317, 0.0761001136283793], [0.9200993341504, 0.0571344254268572], [0.967226838566306, 0.0369537897708524], [0.993752170620389, 0.0160172282577743]], [[-0.994294585482399, 0.0146279952982722], [-0.970060497835428, 0.0337749015848141], [-0.926956772187174, 0.0522933351526832], [-0.8658125777203, 0.0697964684245204], [-0.787816805979208, 0.0859416062170677], [-0.694487263186682, 0.10041414444288], [-0.587640403506911, 0.112932296080539], [-0.469355837986757, 0.123252376810512], [-0.341935820892084, 0.131173504787062], [-0.207860426688221, 0.136541498346015], [-0.0697392733197222, 0.139251872855631], [0.0697392733197222, 0.139251872855631], [0.207860426688221, 0.136541498346015], [0.341935820892084, 0.131173504787062], [0.469355837986757, 0.123252376810512], [0.587640403506911, 0.112932296080539], [0.694487263186682, 0.10041414444288], [0.787816805979208, 0.0859416062170677], [0.8658125777203, 0.0697964684245204], [0.926956772187174, 0.0522933351526832], [0.970060497835428, 0.0337749015848141], [0.994294585482399, 0.0146279952982722]], [[-0.994769334997552, 0.0134118594871417], [-0.972542471218115, 0.0309880058569794], [-0.932971086826016, 0.0480376717310846], [-0.876752358270441, 0.0642324214085258], [-0.804888401618839, 0.0792814117767189], [-0.71866136313195, 0.0929157660600351], [-0.619609875763646, 0.104892091464541], [-0.509501477846007, 0.114996640222411], [-0.39030103803029, 0.123049084306729], [-0.264135680970344, 0.128905722188082], [-0.133256824298466, 0.132462039404696], [0, 0.133654572186106], [0.133256824298466, 0.132462039404696], [0.264135680970344, 0.128905722188082], [0.39030103803029, 0.123049084306729], [0.509501477846007, 0.114996640222411], [0.619609875763646, 0.104892091464541], [0.71866136313195, 0.0929157660600351], [0.804888401618839, 0.0792814117767189], [0.876752358270441, 0.0642324214085258], [0.932971086826016, 0.0480376717310846], [0.972542471218115, 0.0309880058569794], [0.994769334997552, 0.0134118594871417]], [[-0.995187219997021, 0.0123412297999872], [-0.974728555971309, 0.0285313886289336], [-0.938274552002732, 0.0442774388174198], [-0.886415527004401, 0.0592985849154367], [-0.820001985973902, 0.0733464814110803], [-0.740124191578554, 0.0861901615319532], [-0.648093651936975, 0.0976186521041138], [-0.545421471388839, 0.107444270115965], [-0.433793507626045, 0.115505668053725], [-0.315042679696163, 0.121670472927803], [-0.191118867473616, 0.125837456346828], [-0.0640568928626056, 0.127938195346752], [0.0640568928626056, 0.127938195346752], [0.191118867473616, 0.125837456346828], [0.315042679696163, 0.121670472927803], [0.433793507626045, 0.115505668053725], [0.545421471388839, 0.107444270115965], [0.648093651936975, 0.0976186521041138], [0.740124191578554, 0.0861901615319532], [0.820001985973902, 0.0733464814110803], [0.886415527004401, 0.0592985849154367], [0.938274552002732, 0.0442774388174198], [0.974728555971309, 0.0285313886289336], [0.995187219997021, 0.0123412297999872]], [[-0.995556969790498, 0.0113937985010262], [-0.976663921459517, 0.0263549866150321], [-0.942974571228974, 0.0409391567013063], [-0.894991997878275, 0.0549046959758351], [-0.833442628760834, 0.0680383338123569], [-0.759259263037357, 0.080140700335001], [-0.673566368473468, 0.0910282619829636], [-0.577662930241222, 0.10053594906705], [-0.473002731445714, 0.108519624474263], [-0.361172305809387, 0.114858259145711], [-0.243866883720988, 0.119455763535784], [-0.12286469261071, 0.12224244299031], [0, 0.123176053726715], [0.12286469261071, 0.12224244299031], [0.243866883720988, 0.119455763535784], [0.361172305809387, 0.114858259145711], [0.473002731445714, 0.108519624474263], [0.577662930241222, 0.10053594906705], [0.673566368473468, 0.0910282619829636], [0.759259263037357, 0.080140700335001], [0.833442628760834, 0.0680383338123569], [0.894991997878275, 0.0549046959758351], [0.942974571228974, 0.0409391567013063], [0.976663921459517, 0.0263549866150321], [0.995556969790498, 0.0113937985010262]], [[-0.995885701145616, 0.010551372617343], [-0.97838544595647, 0.0244178510926319], [-0.947159066661714, 0.0379623832943627], [-0.902637861984307, 0.0509758252971478], [-0.845445942788498, 0.0632740463295748], [-0.776385948820678, 0.0746841497656597], [-0.696427260419957, 0.0850458943134852], [-0.606692293017618, 0.0942138003559141], [-0.508440714824505, 0.102059161094425], [-0.403051755123486, 0.108471840528576], [-0.292004839485956, 0.113361816546319], [-0.17685882035689, 0.116660443485296], [-0.0592300934293132, 0.118321415279262], [0.0592300934293132, 0.118321415279262], [0.17685882035689, 0.116660443485296], [0.292004839485956, 0.113361816546319], [0.403051755123486, 0.108471840528576], [0.508440714824505, 0.102059161094425], [0.606692293017618, 0.0942138003559141], [0.696427260419957, 0.0850458943134852], [0.776385948820678, 0.0746841497656597], [0.845445942788498, 0.0632740463295748], [0.902637861984307, 0.0509758252971478], [0.947159066661714, 0.0379623832943627], [0.97838544595647, 0.0244178510926319], [0.995885701145616, 0.010551372617343]], [[-0.996179262888988, 0.00979899605129436], [-0.979923475961501, 0.0226862315961806], [-0.950900557814705, 0.0352970537574197], [-0.909482320677491, 0.047449412520615], [-0.856207908018294, 0.0589835368598335], [-0.791771639070508, 0.0697488237662455], [-0.717013473739423, 0.0796048677730577], [-0.632907971946495, 0.0884231585437569], [-0.540551564579456, 0.0960887273700285], [-0.441148251750026, 0.102501637817745], [-0.335993903638508, 0.107578285788533], [-0.226459365439536, 0.111252488356845], [-0.113972585609529, 0.113476346108965], [0, 0.114220867378956], [0.113972585609529, 0.113476346108965], [0.226459365439536, 0.111252488356845], [0.335993903638508, 0.107578285788533], [0.441148251750026, 0.102501637817745], [0.540551564579456, 0.0960887273700285], [0.632907971946495, 0.0884231585437569], [0.717013473739423, 0.0796048677730577], [0.791771639070508, 0.0697488237662455], [0.856207908018294, 0.0589835368598336], [0.909482320677491, 0.047449412520615], [0.950900557814705, 0.0352970537574197], [0.979923475961501, 0.0226862315961806], [0.996179262888988, 0.00979899605129436]], [[-0.996442497573954, 0.00912428259309452], [-0.981303165370872, 0.0211321125927712], [-0.954259280628938, 0.0329014277823043], [-0.915633026392132, 0.0442729347590042], [-0.865892522574395, 0.0551073456757167], [-0.805641370917179, 0.0652729239669995], [-0.735610878013631, 0.0746462142345687], [-0.656651094038864, 0.0831134172289012], [-0.569720471811401, 0.0905717443930328], [-0.475874224955118, 0.0969306579979299], [-0.376251516089078, 0.10211296757806], [-0.272061627635178, 0.106055765922846], [-0.16456928213338, 0.108711192258294], [-0.0550792898840342, 0.110047013016475], [0.0550792898840342, 0.110047013016475], [0.16456928213338, 0.108711192258294], [0.272061627635178, 0.106055765922846], [0.376251516089078, 0.10211296757806], [0.475874224955118, 0.0969306579979299], [0.569720471811401, 0.0905717443930328], [0.656651094038864, 0.0831134172289012], [0.735610878013631, 0.0746462142345687], [0.805641370917179, 0.0652729239669995], [0.865892522574395, 0.0551073456757167], [0.915633026392132, 0.0442729347590042], [0.954259280628938, 0.0329014277823043], [0.981303165370872, 0.0211321125927712], [0.996442497573954, 0.00912428259309452]], [[-0.996679442260596, 0.00851690387874641], [-0.982545505261413, 0.0197320850561227], [-0.957285595778087, 0.0307404922020936], [-0.921180232953058, 0.0414020625186828], [-0.874637804920102, 0.0515948269024979], [-0.818185487615252, 0.0612030906570791], [-0.752462851734477, 0.0701179332550512], [-0.678214537602686, 0.0782383271357637], [-0.596281797138227, 0.0854722573661725], [-0.507592955124227, 0.0917377571392587], [-0.413152888174008, 0.0969638340944086], [-0.314031637867639, 0.101091273759914], [-0.211352286166001, 0.104073310077729], [-0.106278230132679, 0.10587615509732], [0, 0.106479381718314], [0.106278230132679, 0.10587615509732], [0.211352286166001, 0.104073310077729], [0.314031637867639, 0.101091273759914], [0.413152888174008, 0.0969638340944086], [0.507592955124227, 0.0917377571392587], [0.596281797138227, 0.0854722573661725], [0.678214537602686, 0.0782383271357637], [0.752462851734477, 0.0701179332550512], [0.818185487615252, 0.0612030906570791], [0.874637804920102, 0.0515948269024979], [0.921180232953058, 0.0414020625186828], [0.957285595778087, 0.0307404922020936], [0.982545505261413, 0.0197320850561227], [0.996679442260596, 0.00851690387874641]], [[-0.996893484074649, 0.0079681924961666], [-0.983668123279747, 0.0184664683110909], [-0.960021864968307, 0.0287847078833233], [-0.926200047429274, 0.038799192569627], [-0.882560535792052, 0.048402672830594], [-0.829565762382768, 0.057493156217619], [-0.767777432104826, 0.0659742298821805], [-0.697850494793315, 0.0737559747377052], [-0.620526182989242, 0.0807558952294202], [-0.536624148142019, 0.0868997872010829], [-0.447033769538089, 0.0921225222377861], [-0.352704725530878, 0.0963687371746442], [-0.254636926167889, 0.0995934205867952], [-0.153869913608583, 0.101762389748405], [-0.0514718425553176, 0.102852652893558], [0.0514718425553176, 0.102852652893558], [0.153869913608583, 0.101762389748405], [0.254636926167889, 0.0995934205867952], [0.352704725530878, 0.0963687371746442], [0.447033769538089, 0.0921225222377861], [0.536624148142019, 0.0868997872010829], [0.620526182989242, 0.0807558952294202], [0.697850494793315, 0.0737559747377052], [0.767777432104826, 0.0659742298821805], [0.829565762382768, 0.057493156217619], [0.882560535792052, 0.048402672830594], [0.926200047429274, 0.038799192569627], [0.960021864968307, 0.0287847078833233], [0.983668123279747, 0.0184664683110909], [0.996893484074649, 0.0079681924961666]]];
var maxOrder = lut.length + 5;
var NumericalCurveMapper = function(_super) {
  function NumericalCurveMapper2(nQuadraturePoints, nInverseSamples, onInvalidateCache) {
    void 0 === nQuadraturePoints && (nQuadraturePoints = 24), void 0 === nInverseSamples && (nInverseSamples = 21);
    var _this = _super.call(this, onInvalidateCache) || this;
    return _this._nSamples = 21, _this._gauss = function(order) {
      if (order < 5 || order > maxOrder)
        throw Error("Order for Gaussian Quadrature must be in the range of ".concat(5, " and ").concat(maxOrder, "."));
      return lut[order - 5];
    }(nQuadraturePoints), _this._nSamples = nInverseSamples, _this;
  }
  return __extends(NumericalCurveMapper2, _super), NumericalCurveMapper2.prototype._invalidateCache = function() {
    _super.prototype._invalidateCache.call(this), this._cache.arcLengths = null, this._cache.samples = null;
  }, Object.defineProperty(NumericalCurveMapper2.prototype, "arcLengths", { get: function() {
    return this._cache.arcLengths || (this._cache.arcLengths = this.computeArcLengths()), this._cache.arcLengths;
  }, enumerable: false, configurable: true }), NumericalCurveMapper2.prototype.getSamples = function(idx) {
    if (this.points) {
      if (this._cache.samples || (this._cache.samples = /* @__PURE__ */ new Map()), !this._cache.samples.has(idx)) {
        for (var samples = this._nSamples, lengths = [], slopes = [], coefficients = this.getCoefficients(idx), i = 0; i < samples; ++i) {
          var ti = i / (samples - 1);
          lengths.push(this.computeArcLength(idx, 0, ti));
          var dtln = magnitude(evaluateForT(derivativeAtT, ti, coefficients)), slope = 0 === dtln ? 0 : 1 / dtln;
          this.tension > 0.95 && (slope = clamp(slope, -1, 1)), slopes.push(slope);
        }
        var nCoeff = samples - 1, dis = [], cis = [], li_prev = lengths[0], tdi_prev = slopes[0], step = 1 / nCoeff;
        for (i = 0; i < nCoeff; ++i) {
          var li = li_prev, lDiff = (li_prev = lengths[i + 1]) - li, tdi = tdi_prev, tdi_next = slopes[i + 1];
          tdi_prev = tdi_next;
          var si = step / lDiff, di = (tdi + tdi_next - 2 * si) / (lDiff * lDiff), ci = (3 * si - 2 * tdi - tdi_next) / lDiff;
          dis.push(di), cis.push(ci);
        }
        this._cache.samples.set(idx, [lengths, slopes, cis, dis]);
      }
      return this._cache.samples.get(idx);
    }
  }, NumericalCurveMapper2.prototype.computeArcLength = function(index, t0, t1) {
    if (void 0 === t0 && (t0 = 0), void 0 === t1 && (t1 = 1), t0 === t1)
      return 0;
    for (var coefficients = this.getCoefficients(index), z = 0.5 * (t1 - t0), sum = 0, i = 0; i < this._gauss.length; i++) {
      var _a = this._gauss[i], T = _a[0];
      sum += _a[1] * magnitude(evaluateForT(derivativeAtT, z * T + z + t0, coefficients));
    }
    return z * sum;
  }, NumericalCurveMapper2.prototype.computeArcLengths = function() {
    if (this.points) {
      var lengths = [];
      lengths.push(0);
      for (var nPoints = this.closed ? this.points.length : this.points.length - 1, tl = 0, i = 0; i < nPoints; i++) {
        tl += this.computeArcLength(i), lengths.push(tl);
      }
      return lengths;
    }
  }, NumericalCurveMapper2.prototype.inverse = function(idx, len) {
    var step = 1 / (this._nSamples - 1), _a = this.getSamples(idx), lengths = _a[0], slopes = _a[1], cis = _a[2], dis = _a[3];
    if (len >= lengths[lengths.length - 1])
      return 1;
    if (len <= 0)
      return 0;
    var i = Math.max(0, binarySearch(len, lengths)), ti = i * step;
    if (lengths[i] === len)
      return ti;
    var tdi = slopes[i], di = dis[i], ci = cis[i], ld = len - lengths[i];
    return ((di * ld + ci) * ld + tdi) * ld + ti;
  }, NumericalCurveMapper2.prototype.lengthAt = function(u) {
    return u * this.arcLengths[this.arcLengths.length - 1];
  }, NumericalCurveMapper2.prototype.getT = function(u) {
    var arcLengths = this.arcLengths, il = arcLengths.length, targetArcLength = u * arcLengths[il - 1], i = binarySearch(targetArcLength, arcLengths), ti = i / (il - 1);
    if (arcLengths[i] === targetArcLength)
      return ti;
    var len = targetArcLength - arcLengths[i];
    return (i + this.inverse(i, len)) / (il - 1);
  }, NumericalCurveMapper2.prototype.getU = function(t) {
    if (0 === t)
      return 0;
    if (1 === t)
      return 1;
    var arcLengths = this.arcLengths, al = arcLengths.length - 1, totalLength = arcLengths[al], tIdx = t * al, subIdx = Math.floor(tIdx), l1 = arcLengths[subIdx];
    if (tIdx === subIdx)
      return l1 / totalLength;
    var t0 = tIdx - subIdx;
    return (l1 + this.computeArcLength(subIdx, 0, t0)) / totalLength;
  }, NumericalCurveMapper2;
}(AbstractCurveMapper);
var CurveInterpolator = function() {
  function CurveInterpolator2(points, options) {
    void 0 === options && (options = {});
    var _this = this;
    this._cache = /* @__PURE__ */ new Map();
    var curveMapper = (options = __assign({ tension: 0.5, alpha: 0, closed: false }, options)).arcDivisions ? new SegmentedCurveMapper(options.arcDivisions, function() {
      return _this._invalidateCache();
    }) : new NumericalCurveMapper(options.numericalApproximationOrder, options.numericalInverseSamples, function() {
      return _this._invalidateCache();
    });
    curveMapper.alpha = options.alpha, curveMapper.tension = options.tension, curveMapper.closed = options.closed, curveMapper.points = points, this._lmargin = options.lmargin || 1 - curveMapper.tension, this._curveMapper = curveMapper;
  }
  return CurveInterpolator2.prototype.getTimeFromPosition = function(position, clampInput) {
    return void 0 === clampInput && (clampInput = false), this._curveMapper.getT(clampInput ? clamp(position, 0, 1) : position);
  }, CurveInterpolator2.prototype.getPositionFromTime = function(t, clampInput) {
    return void 0 === clampInput && (clampInput = false), this._curveMapper.getU(clampInput ? clamp(t, 0, 1) : t);
  }, CurveInterpolator2.prototype.getPositionFromLength = function(length, clampInput) {
    void 0 === clampInput && (clampInput = false);
    var l = clampInput ? clamp(length, 0, this.length) : length;
    return this._curveMapper.getU(l / this.length);
  }, CurveInterpolator2.prototype.getLengthAt = function(position, clampInput) {
    return void 0 === position && (position = 1), void 0 === clampInput && (clampInput = false), this._curveMapper.lengthAt(clampInput ? clamp(position, 0, 1) : position);
  }, CurveInterpolator2.prototype.getTimeAtKnot = function(index) {
    if (index < 0 || index > this.points.length - 1)
      throw Error("Invalid index!");
    return 0 === index ? 0 : this.closed || index !== this.points.length - 1 ? index / (this.closed ? this.points.length : this.points.length - 1) : 1;
  }, CurveInterpolator2.prototype.getPositionAtKnot = function(index) {
    return this.getPositionFromTime(this.getTimeAtKnot(index));
  }, CurveInterpolator2.prototype.getPointAtTime = function(t, target) {
    return 0 === (t = clamp(t, 0, 1)) ? copyValues(this.points[0], target) : 1 === t ? copyValues(this.closed ? this.points[0] : this.points[this.points.length - 1], target) : this._curveMapper.evaluateForT(valueAtT, t, target);
  }, CurveInterpolator2.prototype.getPointAt = function(position, target) {
    return this.getPointAtTime(this.getTimeFromPosition(position), target);
  }, CurveInterpolator2.prototype.getTangentAt = function(position, target) {
    var t = clamp(this.getTimeFromPosition(position), 0, 1);
    return this.getTangentAtTime(t, target);
  }, CurveInterpolator2.prototype.getTangentAtTime = function(t, target) {
    return normalize(this._curveMapper.evaluateForT(derivativeAtT, t, target));
  }, CurveInterpolator2.prototype.getNormalAt = function(position, target) {
    var t = clamp(this.getTimeFromPosition(position), 0, 1);
    return this.getNormalAtTime(t, target);
  }, CurveInterpolator2.prototype.getNormalAtTime = function(t, target) {
    var dt = normalize(this._curveMapper.evaluateForT(derivativeAtT, t));
    if (!(dt.length < 2 || dt.length > 3)) {
      var normal = target || new Array(dt.length);
      if (2 === dt.length)
        return normal[0] = -dt[1], normal[1] = dt[0], normal;
      var ddt = normalize(this._curveMapper.evaluateForT(secondDerivativeAtT, t));
      return normalize(cross(cross(dt, ddt), dt), normal);
    }
  }, CurveInterpolator2.prototype.getFrenetFrames = function(segments, from, to) {
    if (void 0 === from && (from = 0), void 0 === to && (to = 1), !(from < 0 || to > 1 || to < from)) {
      for (var tangents = new Array(segments + 1), normals = new Array(segments + 1), i = 0; i <= segments; i++) {
        var u = 0 === from && 1 === to ? i / segments : from + i / segments * (to - from);
        tangents[i] = this.getTangentAt(u);
      }
      if (2 === this.dim) {
        for (i = 0; i < tangents.length; i++)
          normals[i] = [-tangents[i][1], tangents[i][0]];
        return { tangents, normals };
      }
      if (3 === this.dim) {
        var binormals = new Array(segments + 1), normal = void 0, min = Number.MAX_VALUE, tx = Math.abs(tangents[0][0]), ty = Math.abs(tangents[0][1]);
        tx <= min && (min = tx, normal = [1, 0, 0]), ty <= min && (min = ty, normal = [0, 1, 0]), Math.abs(tangents[0][2]) <= min && (normal = [0, 0, 1]);
        var vec = normalize(cross(tangents[0], normal));
        normals[0] = cross(tangents[0], vec), binormals[0] = cross(tangents[0], normals[0]);
        for (i = 1; i <= segments; i++) {
          if (vec = cross(tangents[i - 1], tangents[i]), normals[i] = copyValues(normals[i - 1]), magnitude(vec) > EPS) {
            normalize(vec);
            var theta = Math.acos(clamp(dot(tangents[i - 1], tangents[i]), -1, 1));
            rotate3d(normals[i - 1], vec, theta, normals[i]);
          }
          binormals[i] = cross(tangents[i], normals[i]);
        }
        if (true === this.closed) {
          theta = Math.acos(clamp(dot(normals[0], normals[segments]), -1, 1)) / segments;
          dot(tangents[0], cross(normals[0], normals[segments])) > 0 && (theta = -theta);
          for (i = 1; i <= segments; i++)
            rotate3d(normals[i], tangents[i], theta * i, normals[i]), binormals[i] = cross(tangents[i], normals[i]);
        }
        return { tangents, normals, binormals };
      }
    }
  }, CurveInterpolator2.prototype.getCurvatureAt = function(position) {
    var t = clamp(this.getTimeFromPosition(position), 0, 1);
    return this.getCurvatureAtTime(t);
  }, CurveInterpolator2.prototype.getCurvatureAtTime = function(t) {
    var dt = this._curveMapper.evaluateForT(derivativeAtT, t), ddt = this._curveMapper.evaluateForT(secondDerivativeAtT, t), tangent = normalize(dt, []), curvature = 0, direction = void 0;
    if (2 === dt.length) {
      if (0 !== (denominator = Math.pow(dt[0] * dt[0] + dt[1] * dt[1], 1.5))) {
        var signedCurvature = (dt[0] * ddt[1] - dt[1] * ddt[0]) / denominator;
        direction = signedCurvature < 0 ? [tangent[1], -tangent[0]] : [-tangent[1], tangent[0]], curvature = Math.abs(signedCurvature);
      }
    } else if (3 === dt.length) {
      var a = magnitude(dt), cp = cross(dt, ddt);
      direction = normalize(cross(cp, dt)), 0 !== a && (curvature = magnitude(cp) / Math.pow(a, 3));
    } else {
      a = magnitude(dt);
      var b = magnitude(ddt), denominator = Math.pow(a, 3), dotProduct = dot(dt, ddt);
      0 !== denominator && (curvature = Math.sqrt(Math.pow(a, 2) * Math.pow(b, 2) - Math.pow(dotProduct, 2)) / denominator);
    }
    return { curvature, radius: 0 !== curvature ? 1 / curvature : 0, tangent, direction };
  }, CurveInterpolator2.prototype.getDerivativeAt = function(position, target) {
    var t = clamp(this.getTimeFromPosition(position), 0, 1);
    return this._curveMapper.evaluateForT(derivativeAtT, t, target);
  }, CurveInterpolator2.prototype.getSecondDerivativeAt = function(position, target) {
    var t = clamp(this.getTimeFromPosition(position), 0, 1);
    return this._curveMapper.evaluateForT(secondDerivativeAtT, t, target);
  }, CurveInterpolator2.prototype.getBoundingBox = function(from, to) {
    if (void 0 === from && (from = 0), void 0 === to && (to = 1), 0 === from && 1 === to && this._cache.has("bbox"))
      return this._cache.get("bbox");
    for (var min = [], max = [], t0 = this.getTimeFromPosition(from), t1 = this.getTimeFromPosition(to), start = this.getPointAtTime(t0), end = this.getPointAtTime(t1), nPoints = this.closed ? this.points.length : this.points.length - 1, i0 = Math.floor(nPoints * t0), i1 = Math.ceil(nPoints * t1), c = 0; c < start.length; c++)
      min[c] = Math.min(start[c], end[c]), max[c] = Math.max(start[c], end[c]);
    for (var _loop_1 = function(i2) {
      var p2 = getControlPoints(i2 - 1, this_1.points, this_1.closed)[2];
      if (i2 < i1)
        for (var c2 = 0; c2 < p2.length; c2++)
          p2[c2] < min[c2] && (min[c2] = p2[c2]), p2[c2] > max[c2] && (max[c2] = p2[c2]);
      if (this_1.tension < 1) {
        var w0_1 = nPoints * t0 - (i2 - 1), w1_1 = nPoints * t1 - (i2 - 1), valid = function(t) {
          return t > -EPS && t <= 1 + EPS && (i2 - 1 !== i0 || t > w0_1) && (i2 !== i1 || t < w1_1);
        }, coefficients_1 = this_1._curveMapper.getCoefficients(i2 - 1), _loop_2 = function(c3) {
          var _b = coefficients_1[c3];
          getQuadRoots(3 * _b[0], 2 * _b[1], _b[2]).filter(valid).forEach(function(t) {
            var v = valueAtT(t, coefficients_1[c3]);
            v < min[c3] && (min[c3] = v), v > max[c3] && (max[c3] = v);
          });
        };
        for (c2 = 0; c2 < coefficients_1.length; c2++)
          _loop_2(c2);
      }
    }, this_1 = this, i = i0 + 1; i <= i1; i++)
      _loop_1(i);
    var bbox = { min, max };
    return 0 === from && 1 === to && this._cache.set("bbox", bbox), bbox;
  }, CurveInterpolator2.prototype.getPoints = function(segments, returnType, from, to) {
    if (void 0 === segments && (segments = 100), void 0 === from && (from = 0), void 0 === to && (to = 1), !segments || segments <= 0)
      throw Error("Invalid arguments passed to getPoints(). You must specify at least 1 sample/segment.");
    if (!(from < 0 || to > 1 || to < from)) {
      for (var pts = [], d = 0; d <= segments; d++) {
        var u = 0 === from && 1 === to ? d / segments : from + d / segments * (to - from);
        pts.push(this.getPointAt(u, returnType && new returnType()));
      }
      return pts;
    }
  }, CurveInterpolator2.prototype.getNearestPosition = function(point, threshold, samples) {
    var _this = this;
    if (void 0 === threshold && (threshold = 1e-5), threshold <= 0 || !Number.isFinite(threshold))
      throw Error("Invalid threshold. Must be a number greater than zero!");
    samples = samples || 10 * this.points.length - 1;
    var pu = new Array(point.length), minDist = 1 / 0, minU = 0, lut2 = this.createLookupTable(function(u) {
      return _this.getPointAt(u);
    }, samples, { cacheKey: "lut_nearest_".concat(samples) });
    Array.from(lut2.keys()).forEach(function(key) {
      var c = lut2.get(key), dist = distance(point, c);
      if (dist < minDist)
        return minDist = dist, minU = key, true;
    });
    for (var minT = this.getTimeFromPosition(minU), bisect = function(t) {
      if (t >= 0 && t <= 1) {
        _this.getPointAtTime(t, pu);
        var dist = distance(point, pu);
        if (dist < minDist)
          return minDist = dist, minT = t, true;
      }
    }, step = 5e-3; step > threshold; )
      bisect(minT - step) || bisect(minT + step) || (step /= 2);
    return { u: minU = this._curveMapper.getU(minT), distance: minDist, point: pu };
  }, CurveInterpolator2.prototype.getIntersects = function(v, axis, max, margin) {
    var _this = this;
    void 0 === axis && (axis = 0), void 0 === max && (max = 0), void 0 === margin && (margin = this._lmargin);
    var solutions = this.getIntersectsAsTime(v, axis, max, margin).map(function(t) {
      return _this.getPointAtTime(t);
    });
    return 1 === Math.abs(max) ? 1 === solutions.length ? solutions[0] : null : solutions;
  }, CurveInterpolator2.prototype.getIntersectsAsPositions = function(v, axis, max, margin) {
    var _this = this;
    return void 0 === axis && (axis = 0), void 0 === max && (max = 0), void 0 === margin && (margin = this._lmargin), this.getIntersectsAsTime(v, axis, max, margin).map(function(t) {
      return _this.getPositionFromTime(t);
    });
  }, CurveInterpolator2.prototype.getIntersectsAsTime = function(v, axis, max, margin) {
    void 0 === axis && (axis = 0), void 0 === max && (max = 0), void 0 === margin && (margin = this._lmargin);
    for (var k = axis, solutions = /* @__PURE__ */ new Set(), nPoints = this.closed ? this.points.length : this.points.length - 1, i = 0; i < nPoints && (0 === max || solutions.size < Math.abs(max)); i += 1) {
      var idx = max < 0 ? nPoints - (i + 1) : i, _a = getControlPoints(idx, this.points, this.closed), p1 = _a[1], p2 = _a[2], coefficients = this._curveMapper.getCoefficients(idx), vmin = void 0, vmax = void 0;
      if (p1[k] < p2[k] ? (vmin = p1[k], vmax = p2[k]) : (vmin = p2[k], vmax = p1[k]), v - margin <= vmax && v + margin >= vmin) {
        var ts = findRootsOfT(v, coefficients[k]);
        max < 0 ? ts.sort(function(a, b) {
          return b - a;
        }) : max >= 0 && ts.sort(function(a, b) {
          return a - b;
        });
        for (var j = 0; j < ts.length; j++) {
          var nt = (ts[j] + idx) / nPoints;
          if (solutions.add(nt), 0 !== max && solutions.size === Math.abs(max))
            break;
        }
      }
    }
    return Array.from(solutions);
  }, CurveInterpolator2.prototype.createLookupTable = function(func, samples, options) {
    if (!samples || samples <= 1)
      throw Error("Invalid arguments passed to createLookupTable(). You must specify at least 2 samples.");
    var _a = __assign({ from: 0, to: 1, cacheForceUpdate: false }, options), from = _a.from, to = _a.to, cacheKey = _a.cacheKey, cacheForceUpdate = _a.cacheForceUpdate;
    if (!(from < 0 || to > 1 || to < from)) {
      var lut2 = null;
      if (cacheKey && !cacheForceUpdate && this._cache.has(cacheKey))
        cacheKey && this._cache.has(cacheKey) && (lut2 = this._cache.get(cacheKey));
      else {
        lut2 = /* @__PURE__ */ new Map();
        for (var d = 0; d < samples; d++) {
          var u = 0 === from && 1 === to ? d / (samples - 1) : from + d / (samples - 1) * (to - from), value = func(u);
          lut2.set(u, value);
        }
        cacheKey && this._cache.set(cacheKey, lut2);
      }
      return lut2;
    }
  }, CurveInterpolator2.prototype.forEach = function(func, samples, from, to) {
    var _this = this;
    void 0 === from && (from = 0), void 0 === to && (to = 1);
    var positions = [];
    if (Number.isFinite(samples)) {
      var nSamples = samples;
      if (nSamples <= 1)
        throw Error("Invalid arguments passed to forEach(). You must specify at least 2 samples.");
      for (var i = 0; i < nSamples; i++) {
        var u = 0 === from && 1 === to ? i / (nSamples - 1) : from + i / (nSamples - 1) * (to - from);
        positions.push(u);
      }
    } else
      Array.isArray(samples) && (positions = samples);
    var prev = null;
    positions.forEach(function(u2, i2) {
      if (!Number.isFinite(u2) || u2 < 0 || u2 > 1)
        throw Error("Invalid position (u) for sample in forEach!");
      var t = _this.getTimeFromPosition(u2), current = func({ u: u2, t, i: i2, prev });
      prev = { u: u2, t, i: i2, value: current };
    });
  }, CurveInterpolator2.prototype.map = function(func, samples, from, to) {
    var _this = this;
    void 0 === from && (from = 0), void 0 === to && (to = 1);
    var positions = [];
    if (Number.isFinite(samples)) {
      var nSamples = samples;
      if (nSamples <= 1)
        throw Error("Invalid arguments passed to map(). You must specify at least 2 samples.");
      for (var i = 0; i < nSamples; i++) {
        var u = 0 === from && 1 === to ? i / (nSamples - 1) : from + i / (nSamples - 1) * (to - from);
        positions.push(u);
      }
    } else
      Array.isArray(samples) && (positions = samples);
    var prev = null;
    return positions.map(function(u2, i2) {
      if (!Number.isFinite(u2) || u2 < 0 || u2 > 1)
        throw Error("Invalid position (u) for sample in map()!");
      var t = _this.getTimeFromPosition(u2), current = func({ u: u2, t, i: i2, prev });
      return prev = { u: u2, t, i: i2, value: current }, current;
    });
  }, CurveInterpolator2.prototype.reduce = function(func, initialValue, samples, from, to) {
    var _this = this;
    void 0 === from && (from = 0), void 0 === to && (to = 1);
    var positions = [];
    if (Number.isFinite(samples)) {
      var nSamples = samples;
      if (nSamples <= 1)
        throw Error("Invalid arguments passed to map(). You must specify at least 2 samples.");
      for (var i = 0; i < nSamples; i++) {
        var u = 0 === from && 1 === to ? i / (nSamples - 1) : from + i / (nSamples - 1) * (to - from);
        positions.push(u);
      }
    } else
      Array.isArray(samples) && (positions = samples);
    return positions.reduce(function(acc, u2, i2) {
      if (!Number.isFinite(u2) || u2 < 0 || u2 > 1)
        throw Error("Invalid position (u) for sample in map()!");
      var t = _this.getTimeFromPosition(u2);
      return func({ acc, u: u2, t, i: i2 });
    }, initialValue);
  }, CurveInterpolator2.prototype._invalidateCache = function() {
    return this._cache = /* @__PURE__ */ new Map(), this;
  }, CurveInterpolator2.prototype.reset = function() {
    this._curveMapper.reset();
  }, Object.defineProperty(CurveInterpolator2.prototype, "points", { get: function() {
    return this._curveMapper.points;
  }, set: function(pts) {
    this._curveMapper.points = pts;
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "tension", { get: function() {
    return this._curveMapper.tension;
  }, set: function(t) {
    this._curveMapper.tension = t;
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "alpha", { get: function() {
    return this._curveMapper.alpha;
  }, set: function(a) {
    this._curveMapper.alpha = a;
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "closed", { get: function() {
    return this._curveMapper.closed;
  }, set: function(isClosed) {
    this._curveMapper.closed = isClosed;
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "length", { get: function() {
    return this._curveMapper.lengthAt(1);
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "minX", { get: function() {
    return this.getBoundingBox().min[0];
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "maxX", { get: function() {
    return this.getBoundingBox().max[0];
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "minY", { get: function() {
    return this.getBoundingBox().min[1];
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "maxY", { get: function() {
    return this.getBoundingBox().max[1];
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "minZ", { get: function() {
    return this.getBoundingBox().min[2];
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "maxZ", { get: function() {
    return this.getBoundingBox().max[2];
  }, enumerable: false, configurable: true }), Object.defineProperty(CurveInterpolator2.prototype, "dim", { get: function() {
    var _a;
    return (null === (_a = this.points[0]) || void 0 === _a ? void 0 : _a.length) || void 0;
  }, enumerable: false, configurable: true }), CurveInterpolator2;
}();
var Point = function() {
  function Point2(x, y, z, w) {
    void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === z && (z = null), void 0 === w && (w = null), this.x = x, this.y = y, this.z = z, this.w = w;
  }
  return Object.defineProperty(Point2.prototype, 0, { get: function() {
    return this.x;
  }, set: function(x) {
    this.x = x;
  }, enumerable: false, configurable: true }), Object.defineProperty(Point2.prototype, 1, { get: function() {
    return this.y;
  }, set: function(y) {
    this.y = y;
  }, enumerable: false, configurable: true }), Object.defineProperty(Point2.prototype, 2, { get: function() {
    return this.z;
  }, set: function(z) {
    this.z = z;
  }, enumerable: false, configurable: true }), Object.defineProperty(Point2.prototype, 3, { get: function() {
    return this.w;
  }, set: function(w) {
    this.w = w;
  }, enumerable: false, configurable: true }), Object.defineProperty(Point2.prototype, "length", { get: function() {
    return Number.isFinite(this.w) ? 4 : Number.isFinite(this.z) ? 3 : 2;
  }, enumerable: false, configurable: true }), Point2;
}();
export {
  CurveInterpolator,
  EPS,
  SegmentedCurveMapper as LinearCurveMapper,
  NumericalCurveMapper,
  Point,
  add,
  binarySearch,
  calcKnotSequence,
  calculateCoefficients,
  clamp,
  copyValues,
  cross,
  derivativeAtT,
  distance,
  dot,
  evaluateForT,
  extrapolateControlPoint,
  fill,
  findRootsOfT,
  getControlPoints,
  getCubicRoots,
  getQuadRoots,
  getSegmentIndexAndT,
  magnitude,
  map,
  normalize,
  orthogonal,
  reduce,
  rotate2d,
  rotate3d,
  secondDerivativeAtT,
  simplify2d,
  sub,
  sumOfSquares,
  valueAtT
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=curve-interpolator.js.map
